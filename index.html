<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Baby Sleep Timeline (18:00–18:00)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }

    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .controls label {
      font-size: 13px;
      color: #374151;
    }
    .controls select {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
      background: white;
    }

    #chart {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
    }
    .axis text { font-size: 11px; }
    .column-label { font-size: 11px; fill: #111827; font-weight: 500; }
    .bar { rx: 4; ry: 4; }
    .bar.sleep { opacity: 0.95; }
    .bar.wake { opacity: 0.45; }
    .bar-label {
      font-size: 11px;
      fill: #1e293b;
      pointer-events: none;
      user-select: none;
      font-weight: 500;
    }
    .bar-label.light { fill: #ffffff; }
    .grid line { stroke: #e5e7eb; stroke-width: 1; }
    .grid path { display: none; }

    .tooltip {
      position: fixed;
      z-index: 9999;
      max-width: 380px;
      background: rgba(17, 24, 39, 0.96);
      color: white;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.35;
      pointer-events: none;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      display: none;
      white-space: pre-line;
    }

    .error {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #7f1d1d;
      padding: 10px 12px;
      border-radius: 8px;
      margin: 12px 0;
      font-size: 13px;
    }

    .legend {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      font-size: 12px;
      color: #374151;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>Baby Sleep Timeline (06:00 → 06:00)</h1>

  <div class="controls">
    <label for="days-select">Show last:</label>
    <select id="days-select">
      <option value="7" selected>7 days</option>
      <option value="14">14 days</option>
      <option value="30">30 days</option>
      <option value="all">All days</option>
    </select>
  </div>

  <div id="errors"></div>
  <div id="chart"></div>
  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch" style="background: #1e40af;"></div>
      <span>Night sleep</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: #60a5fa;"></div>
      <span>Day sleep</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: #d1d5db;"></div>
      <span>Awake</span>
    </div>
  </div>
  <div id="tooltip" class="tooltip"></div>

  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <!-- Luxon for timezones and boundary logic -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>

  <script type="module">
    const { DateTime, Duration } = luxon;

    /**
     * =========================
     * Wrangling Layer (pure-ish)
     * =========================
     */

    /**
     * Format a duration in seconds into "2h 58m", "14m", "1h 02m".
     * (Always minutes resolution for readability, with 2-digit minutes when hours exist.)
     */
    function formatDurationPretty(seconds) {
      const s = Math.max(0, Math.floor(seconds));
      const totalMinutes = Math.round(s / 60); // round to nearest minute for display
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;

      if (h <= 0) return `${m}m`;
      return `${h}h ${String(m).padStart(2, "0")}m`;
    }

    function dtFromISO(iso, tz) {
      // Parse with offset if present, then convert to target tz.
      return DateTime.fromISO(iso, { setZone: true }).setZone(tz);
    }

    /**
     * Given a datetime, return the sleep-day window start (18:00 local).
     */
    function sleepDayWindowStart(dt, sleepDayStartHour = 18) {
      const boundary = dt.startOf("day").plus({ hours: sleepDayStartHour });
      return dt < boundary ? boundary.minus({ days: 1 }) : boundary;
    }

    function sleepDayIdFromDt(dt, sleepDayStartHour = 18) {
      return sleepDayWindowStart(dt, sleepDayStartHour).toISODate(); // e.g., "2025-12-08"
    }

    /**
     * Split an interval at sleep-day boundaries (18:00→18:00) so that each segment lives in exactly one sleep-day.
     * Returns array of { sleep_day_id, window_start, window_end, start, end }
     */
    function splitBySleepDayBoundaries(start, end, sleepDayStartHour = 18) {
      if (!(start instanceof DateTime) || !(end instanceof DateTime)) {
        throw new Error("splitBySleepDayBoundaries requires Luxon DateTime objects.");
      }
      if (end <= start) return [];

      const out = [];
      let cursor = start;

      while (cursor < end) {
        const windowStart = sleepDayWindowStart(cursor, sleepDayStartHour);
        const windowEnd = windowStart.plus({ days: 1 });
        const segEnd = end < windowEnd ? end : windowEnd;
        out.push({
          sleep_day_id: windowStart.toISODate(),
          window_start: windowStart,
          window_end: windowEnd,
          start: cursor,
          end: segEnd,
        });
        cursor = segEnd;
      }

      return out;
    }

    /**
     * Validate no overlaps within each sleep-day.
     * Throws Error with details if overlap is found.
     */
    function validateNoOverlapsBySleepDay(sleepSegmentsByDay) {
      for (const [sleepDayId, segs] of sleepSegmentsByDay.entries()) {
        const sorted = [...segs].sort((a, b) => a.start.toMillis() - b.start.toMillis());
        for (let i = 1; i < sorted.length; i++) {
          const prev = sorted[i - 1];
          const cur = sorted[i];
          if (cur.start < prev.end) {
            const msg =
              `Invalid data: overlapping sleep intervals in sleep-day ${sleepDayId}\n` +
              `Prev: ${prev.start.toISO()} → ${prev.end.toISO()} (${prev.type})\n` +
              `Cur : ${cur.start.toISO()} → ${cur.end.toISO()} (${cur.type})`;
            throw new Error(msg);
          }
        }
      }
    }

    /**
     * Build the render model:
     * - split sleeps across sleep-day boundaries
     * - validate overlaps
     * - compute wake windows (including window edges)
     * - compute duration_pretty + tooltip details
     */
    function buildSleepChartModel(input) {
      const {
        timezone,
        sleep_day_start_hour = 18,
        events
      } = input;

      // 1) Normalize + split input sleep intervals into per-sleep-day sleep segments
      const sleepSegments = [];
      for (const e of events) {
        const start = dtFromISO(e.start, timezone);
        const end = dtFromISO(e.end, timezone);

        if (end <= start) continue; // or throw; here we silently drop invalid duration

        const splits = splitBySleepDayBoundaries(start, end, sleep_day_start_hour);
        for (const s of splits) {
          const durationSeconds = (s.end.toMillis() - s.start.toMillis()) / 1000;
          sleepSegments.push({
            sleep_day_id: s.sleep_day_id,
            window_start: s.window_start,
            window_end: s.window_end,
            kind: "sleep",
            type: e.type,
            start: s.start,
            end: s.end,
            duration_seconds: durationSeconds,
            duration_pretty: formatDurationPretty(durationSeconds),
            // Keep original metadata attached to each split piece
            start_condition: e.start_condition ?? null,
            end_condition: e.end_condition ?? null,
            start_location: e.start_location ?? null,
            notes: e.notes ?? null,
          });
        }
      }

      // 2) Determine all sleep-days to render (from the segments)
      const sleepDayMap = new Map(); // id -> { id, window_start, window_end }
      for (const seg of sleepSegments) {
        if (!sleepDayMap.has(seg.sleep_day_id)) {
          sleepDayMap.set(seg.sleep_day_id, {
            id: seg.sleep_day_id,
            window_start: seg.window_start,
            window_end: seg.window_end
          });
        }
      }

      const sleepDays = [...sleepDayMap.values()]
        .sort((a, b) => a.window_start.toMillis() - b.window_start.toMillis());

      // 3) Group sleep segments by day, validate overlaps
      const sleepByDay = new Map();
      for (const day of sleepDays) sleepByDay.set(day.id, []);
      for (const seg of sleepSegments) sleepByDay.get(seg.sleep_day_id).push(seg);

      validateNoOverlapsBySleepDay(sleepByDay);

      // 4) Compute wake windows per sleep-day (including edges)
      const allSegments = [];
      for (const day of sleepDays) {
        const sleeps = (sleepByDay.get(day.id) ?? [])
          .slice()
          .sort((a, b) => a.start.toMillis() - b.start.toMillis());

        // push sleeps
        for (const s of sleeps) allSegments.push(s);

        const windowStart = day.window_start;
        const windowEnd = day.window_end;

        // helper to add wake segment if positive
        const addWake = (wStart, wEnd) => {
          if (wEnd <= wStart) return;
          const dur = (wEnd.toMillis() - wStart.toMillis()) / 1000;
          allSegments.push({
            sleep_day_id: day.id,
            window_start: windowStart,
            window_end: windowEnd,
            kind: "wake",
            type: "wake",
            start: wStart,
            end: wEnd,
            duration_seconds: dur,
            duration_pretty: formatDurationPretty(dur),
            start_condition: null,
            end_condition: null,
            start_location: null,
            notes: null,
          });
        };

        if (sleeps.length === 0) {
          // Entire window is wake
          addWake(windowStart, windowEnd);
          continue;
        }

        // edge: start of window -> first sleep
        addWake(windowStart, sleeps[0].start);

        // between sleeps
        for (let i = 0; i < sleeps.length - 1; i++) {
          addWake(sleeps[i].end, sleeps[i + 1].start);
        }

        // edge: last sleep -> end of window
        addWake(sleeps[sleeps.length - 1].end, windowEnd);
      }

      // 5) Build render-friendly fields: offset seconds and tooltip strings
      const sleepDayById = new Map(sleepDays.map(d => [d.id, d]));

      const segments = allSegments.map(seg => {
        const day = sleepDayById.get(seg.sleep_day_id);
        const offsetStart = (seg.start.toMillis() - day.window_start.toMillis()) / 1000;
        const offsetEnd = (seg.end.toMillis() - day.window_start.toMillis()) / 1000;

        const metaLines = [];
        if (seg.start_condition) metaLines.push(`Start condition: ${seg.start_condition}`);
        if (seg.end_condition) metaLines.push(`End condition: ${seg.end_condition}`);
        if (seg.start_location) metaLines.push(`Start location: ${seg.start_location}`);
        if (seg.notes) metaLines.push(`Notes: ${seg.notes}`);

        const details =
          `${seg.kind.toUpperCase()} (${seg.type})\n` +
          `Duration: ${seg.duration_pretty}\n` +
          `Start: ${seg.start.toFormat("yyyy-LL-dd HH:mm")} (${timezone})\n` +
          `End:   ${seg.end.toFormat("yyyy-LL-dd HH:mm")} (${timezone})` +
          (metaLines.length ? `\n\n${metaLines.join("\n")}` : "");

        return {
          ...seg,
          offset_start_s: offsetStart,
          offset_end_s: offsetEnd,
          label: seg.duration_pretty,
          details
        };
      });

      return {
        timezone,
        sleep_day_start_hour,
        sleep_days: sleepDays.map(d => ({
          id: d.id,
          window_start: d.window_start.toISO(),
          window_end: d.window_end.toISO()
        })),
        // Keep Luxon versions internally for render convenience
        _sleep_days_luxon: sleepDays,
        segments
      };
    }

    /**
     * =========================
     * Visualization Layer (D3) - Vertical Orientation
     * =========================
     */

    function renderSleepChart(model, opts = {}) {
      const {
        container = "#chart",
        tooltipEl = "#tooltip",
        columnWidth = 140,      // width per day column (generous)
        columnGap = 10,
        timeAxisWidth = 50,     // left margin for time labels
        chartHeight = 920       // total height for the 24h window (generous)
      } = opts;

      const sleepDays = model._sleep_days_luxon;
      const segments = model.segments;

      const totalSeconds = 24 * 60 * 60; // 18:00 → next 18:00

      // Dimensions
      const width = timeAxisWidth + sleepDays.length * (columnWidth + columnGap) + 20;
      const innerHeight = chartHeight - 60; // leave room for column labels at top

      // Clear
      d3.select(container).selectAll("*").remove();

      const svg = d3.select(container)
        .append("svg")
        .attr("width", width)
        .attr("height", chartHeight);

      const g = svg.append("g").attr("transform", `translate(${timeAxisWidth}, 40)`);

      // Scales
      // Y-axis: time (18:00 at top → next 18:00 at bottom)
      const y = d3.scaleLinear()
        .domain([0, totalSeconds])
        .range([0, innerHeight]);

      // X-axis: sleep-days (columns)
      const x = d3.scaleBand()
        .domain(sleepDays.map(d => d.id))
        .range([0, sleepDays.length * (columnWidth + columnGap)])
        .paddingInner(columnGap / (columnWidth + columnGap));

      // Axis ticks every 2 hours
      const tickEveryHours = 2;
      const ticks = d3.range(0, 24 + 0.0001, tickEveryHours).map(h => h * 3600);

      const tickFormat = (secFromWindowStart) => {
        const base = sleepDays[0]?.window_start ?? DateTime.local();
        const t = base.plus({ seconds: secFromWindowStart });
        return t.toFormat("HH:mm");
      };

      // Horizontal grid lines
      g.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(y)
          .tickValues(ticks)
          .tickSize(-x.range()[1])
          .tickFormat("")
        );

      // Y axis (left) - time labels
      g.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y).tickValues(ticks).tickFormat(tickFormat));

      // Column labels (date at top)
      g.selectAll(".column-label")
        .data(sleepDays)
        .enter()
        .append("text")
        .attr("class", "column-label")
        .attr("x", d => (x(d.id) ?? 0) + columnWidth / 2)
        .attr("y", -12)
        .attr("text-anchor", "middle")
        .text(d => {
          // Format as "Mon 12/08"
          const dt = DateTime.fromISO(d.id);
          return dt.toFormat("ccc MM/dd");
        });

      // Color mapping for sleep types - improved contrast
      const sleepTypeColors = new Map([
        ["night sleep", "#1e40af"], // dark blue (blue-800)
        ["day sleep", "#60a5fa"],   // lighter blue (blue-400)
      ]);
      const wakeColor = "#d1d5db"; // light gray

      const tooltip = document.querySelector(tooltipEl);

      const bars = g.append("g")
        .selectAll("g.segment")
        .data(segments)
        .enter()
        .append("g")
        .attr("class", "segment");

      // Bar rects (vertical bars)
      bars.append("rect")
        .attr("class", d => `bar ${d.kind}`)
        .attr("x", d => x(d.sleep_day_id) ?? 0)
        .attr("y", d => y(d.offset_start_s))
        .attr("width", columnWidth)
        .attr("height", d => Math.max(0, y(d.offset_end_s) - y(d.offset_start_s)))
        .attr("fill", d => {
          if (d.kind === "wake") return wakeColor;
          return sleepTypeColors.get(d.type) ?? "#6ee7b7";
        })
        .on("mousemove", (event, d) => {
          tooltip.style.display = "block";
          tooltip.textContent = d.details;
          const pad = 12;
          tooltip.style.left = `${Math.min(window.innerWidth - 400, event.clientX + pad)}px`;
          tooltip.style.top = `${Math.min(window.innerHeight - 150, event.clientY + pad)}px`;
        })
        .on("mouseleave", () => {
          tooltip.style.display = "none";
        });

      // Duration labels only (metadata in tooltip)
      // If bar is too short, skip label entirely (tooltip has all info)
      const minHeightForDuration = 24;

      // Helper: check if bar needs light (white) text
      const needsLightText = d => d.type === "night sleep";

      bars.filter(d => {
        const barHeight = y(d.offset_end_s) - y(d.offset_start_s);
        return barHeight >= minHeightForDuration;
      })
        .append("text")
        .attr("class", d => needsLightText(d) ? "bar-label light" : "bar-label")
        .attr("x", d => (x(d.sleep_day_id) ?? 0) + columnWidth / 2)
        .attr("y", d => {
          const y0 = y(d.offset_start_s);
          const y1 = y(d.offset_end_s);
          return y0 + (y1 - y0) / 2;
        })
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .attr("font-weight", "600")
        .text(d => d.label);
    }

    /**
     * =========================
     * Load data and render
     * =========================
     */

    const TIMEZONE = "America/Sao_Paulo";
    const SLEEP_DAY_START_HOUR = 6; // Start at 6am (morning)

    let allEvents = [];

    /**
     * Filter events to only include the last N days (based on sleep-day windows)
     */
    function filterEventsByDays(events, numDays) {
      if (numDays === "all" || !numDays) return events;

      // Find the latest sleep-day in the data
      let latestSleepDay = null;
      for (const e of events) {
        const dt = dtFromISO(e.start, TIMEZONE);
        const sleepDayId = sleepDayIdFromDt(dt, SLEEP_DAY_START_HOUR);
        if (!latestSleepDay || sleepDayId > latestSleepDay) {
          latestSleepDay = sleepDayId;
        }
      }

      if (!latestSleepDay) return events;

      // Calculate cutoff date (numDays before the latest)
      const latestDt = DateTime.fromISO(latestSleepDay, { zone: TIMEZONE });
      const cutoffDt = latestDt.minus({ days: numDays - 1 });
      const cutoffId = cutoffDt.toISODate();

      // Filter events where the sleep-day is >= cutoff
      return events.filter(e => {
        const dt = dtFromISO(e.start, TIMEZONE);
        const sleepDayId = sleepDayIdFromDt(dt, SLEEP_DAY_START_HOUR);
        return sleepDayId >= cutoffId;
      });
    }

    function render(numDays) {
      const filteredEvents = filterEventsByDays(allEvents, numDays);

      if (filteredEvents.length === 0) {
        document.querySelector("#errors").innerHTML =
          `<div class="error">No sleep data found. Run <code>make build</code> to generate data/sleep.json</div>`;
        return;
      }

      const input = {
        timezone: TIMEZONE,
        sleep_day_start_hour: SLEEP_DAY_START_HOUR,
        events: filteredEvents
      };

      try {
        document.querySelector("#errors").innerHTML = "";
        const model = buildSleepChartModel(input);
        renderSleepChart(model);
      } catch (err) {
        document.querySelector("#errors").innerHTML =
          `<div class="error"><strong>Validation error</strong><pre style="margin:8px 0 0; white-space:pre-wrap;">${String(err.message)}</pre></div>`;
      }
    }

    // Wire up days selector
    const daysSelect = document.querySelector("#days-select");
    daysSelect.addEventListener("change", () => {
      const val = daysSelect.value;
      render(val === "all" ? "all" : parseInt(val, 10));
    });

    // Load data and render
    fetch("data/sleep.json")
      .then(res => {
        if (!res.ok) throw new Error(`Failed to load data/sleep.json (${res.status})`);
        return res.json();
      })
      .then(data => {
        allEvents = data;
        render(7);
      })
      .catch(err => {
        document.querySelector("#errors").innerHTML =
          `<div class="error"><strong>Failed to load data</strong><br>${err.message}<br><br>Run <code>make build</code> to generate the data file.</div>`;
      });
  </script>
</body>
</html>
