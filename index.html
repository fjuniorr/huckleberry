<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Baby Sleep Timeline (18:00–18:00)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 18px; margin: 0 0 12px; }

    .controls {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }
    .controls label {
      font-size: 13px;
      color: #374151;
    }
    .controls select {
      padding: 6px 10px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
      font-size: 13px;
      background: white;
    }

    #chart {
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 16px;
      overflow-x: auto;
    }
    .axis text { font-size: 11px; }
    .column-label { font-size: 11px; fill: #111827; font-weight: 500; }
    .bar { rx: 4; ry: 4; }
    .bar.sleep { opacity: 0.95; }
    .bar.wake { opacity: 0.45; }
    .bar-label {
      font-size: 11px;
      fill: #1e293b;
      pointer-events: none;
      user-select: none;
      font-weight: 500;
    }
    .bar-label.light { fill: #ffffff; }
    .metadata-indicator { pointer-events: none; }
    .grid line { stroke: #e5e7eb; stroke-width: 1; }
    .grid path { display: none; }

    .tooltip {
      position: fixed;
      z-index: 9999;
      max-width: 380px;
      background: rgba(17, 24, 39, 0.96);
      color: white;
      padding: 10px 12px;
      border-radius: 8px;
      font-size: 12px;
      line-height: 1.35;
      pointer-events: none;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      display: none;
      white-space: pre-line;
    }

    .error {
      background: #fef2f2;
      border: 1px solid #fecaca;
      color: #7f1d1d;
      padding: 10px 12px;
      border-radius: 8px;
      margin: 12px 0;
      font-size: 13px;
    }

    .legend {
      display: flex;
      gap: 16px;
      margin-top: 12px;
      font-size: 12px;
      color: #374151;
    }
    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .legend-swatch {
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
  <h1>Baby Sleep Timeline (06:00 → 06:00)</h1>

  <div class="controls">
    <label for="days-select">Show last:</label>
    <select id="days-select">
      <option value="7" selected>7 days</option>
      <option value="14">14 days</option>
      <option value="30">30 days</option>
      <option value="all">All days</option>
    </select>
  </div>

  <div id="errors"></div>
  <div id="chart"></div>
  <div class="legend">
    <div class="legend-item">
      <div class="legend-swatch" style="background: #1e40af;"></div>
      <span>Night sleep</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: #60a5fa;"></div>
      <span>Day sleep</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: #d1d5db;"></div>
      <span>Awake</span>
    </div>
  </div>
  <div id="tooltip" class="tooltip"></div>

  <!-- D3 -->
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <!-- Luxon for timezones and boundary logic -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>

  <script type="module">
    const { DateTime, Duration } = luxon;

    /**
     * =========================
     * Wrangling Layer (pure-ish)
     * =========================
     */

    /**
     * Format a duration in seconds into "2h 58m", "14m", "1h 02m".
     * (Always minutes resolution for readability, with 2-digit minutes when hours exist.)
     */
    function formatDurationPretty(seconds) {
      const s = Math.max(0, Math.floor(seconds));
      const totalMinutes = Math.round(s / 60); // round to nearest minute for display
      const h = Math.floor(totalMinutes / 60);
      const m = totalMinutes % 60;

      if (h <= 0) return `${m}m`;
      return `${h}h ${String(m).padStart(2, "0")}m`;
    }

    function dtFromISO(iso, tz) {
      // Parse with offset if present, then convert to target tz.
      return DateTime.fromISO(iso, { setZone: true }).setZone(tz);
    }

    /**
     * Given a datetime, return the sleep-day window start (18:00 local).
     */
    function sleepDayWindowStart(dt, sleepDayStartHour = 18) {
      const boundary = dt.startOf("day").plus({ hours: sleepDayStartHour });
      return dt < boundary ? boundary.minus({ days: 1 }) : boundary;
    }

    function sleepDayIdFromDt(dt, sleepDayStartHour = 18) {
      return sleepDayWindowStart(dt, sleepDayStartHour).toISODate(); // e.g., "2025-12-08"
    }

    /**
     * Split an interval at sleep-day boundaries (18:00→18:00) so that each segment lives in exactly one sleep-day.
     * Returns array of { sleep_day_id, window_start, window_end, start, end }
     */
    function splitBySleepDayBoundaries(start, end, sleepDayStartHour = 18) {
      if (!(start instanceof DateTime) || !(end instanceof DateTime)) {
        throw new Error("splitBySleepDayBoundaries requires Luxon DateTime objects.");
      }
      if (end <= start) return [];

      const out = [];
      let cursor = start;

      while (cursor < end) {
        const windowStart = sleepDayWindowStart(cursor, sleepDayStartHour);
        const windowEnd = windowStart.plus({ days: 1 });
        const segEnd = end < windowEnd ? end : windowEnd;
        out.push({
          sleep_day_id: windowStart.toISODate(),
          window_start: windowStart,
          window_end: windowEnd,
          start: cursor,
          end: segEnd,
        });
        cursor = segEnd;
      }

      return out;
    }

    /**
     * Build the render model:
     * - split sleeps across sleep-day boundaries
     * - compute wake windows (including window edges)
     * - compute duration_pretty + tooltip details
     * Note: Overlapping sleep intervals are allowed
     */
    function buildSleepChartModel(input) {
      const {
        timezone,
        sleep_day_start_hour = 18,
        events
      } = input;

      // 1) Normalize + split input sleep intervals into per-sleep-day sleep segments
      const sleepSegments = [];
      for (const e of events) {
        const start = dtFromISO(e.start, timezone);
        const end = dtFromISO(e.end, timezone);

        if (end <= start) continue; // or throw; here we silently drop invalid duration

        const splits = splitBySleepDayBoundaries(start, end, sleep_day_start_hour);
        for (const s of splits) {
          const durationSeconds = (s.end.toMillis() - s.start.toMillis()) / 1000;
          sleepSegments.push({
            sleep_day_id: s.sleep_day_id,
            window_start: s.window_start,
            window_end: s.window_end,
            kind: "sleep",
            type: e.type,
            start: s.start,
            end: s.end,
            duration_seconds: durationSeconds,
            duration_pretty: formatDurationPretty(durationSeconds),
            // Keep original metadata attached to each split piece
            start_condition: e.start_condition ?? null,
            end_condition: e.end_condition ?? null,
            start_location: e.start_location ?? null,
            notes: e.notes ?? null,
          });
        }
      }

      // 2) Determine all sleep-days to render (from the segments)
      const sleepDayMap = new Map(); // id -> { id, window_start, window_end }
      for (const seg of sleepSegments) {
        if (!sleepDayMap.has(seg.sleep_day_id)) {
          sleepDayMap.set(seg.sleep_day_id, {
            id: seg.sleep_day_id,
            window_start: seg.window_start,
            window_end: seg.window_end
          });
        }
      }

      const sleepDays = [...sleepDayMap.values()]
        .sort((a, b) => a.window_start.toMillis() - b.window_start.toMillis());

      // 3) Group sleep segments by day
      const sleepByDay = new Map();
      for (const day of sleepDays) sleepByDay.set(day.id, []);
      for (const seg of sleepSegments) sleepByDay.get(seg.sleep_day_id).push(seg);

      // 4) Compute wake windows per sleep-day (including edges)
      const allSegments = [];
      for (const day of sleepDays) {
        const sleeps = (sleepByDay.get(day.id) ?? [])
          .slice()
          .sort((a, b) => a.start.toMillis() - b.start.toMillis());

        // push sleeps
        for (const s of sleeps) allSegments.push(s);

        const windowStart = day.window_start;
        const windowEnd = day.window_end;

        // helper to add wake segment if positive
        const addWake = (wStart, wEnd) => {
          if (wEnd <= wStart) return;
          const dur = (wEnd.toMillis() - wStart.toMillis()) / 1000;
          allSegments.push({
            sleep_day_id: day.id,
            window_start: windowStart,
            window_end: windowEnd,
            kind: "wake",
            type: "wake",
            start: wStart,
            end: wEnd,
            duration_seconds: dur,
            duration_pretty: formatDurationPretty(dur),
            start_condition: null,
            end_condition: null,
            start_location: null,
            notes: null,
          });
        };

        if (sleeps.length === 0) {
          // Entire window is wake
          addWake(windowStart, windowEnd);
          continue;
        }

        // edge: start of window -> first sleep
        addWake(windowStart, sleeps[0].start);

        // between sleeps
        for (let i = 0; i < sleeps.length - 1; i++) {
          addWake(sleeps[i].end, sleeps[i + 1].start);
        }

        // edge: last sleep -> end of window
        addWake(sleeps[sleeps.length - 1].end, windowEnd);
      }

      // 5) Compute summary statistics per sleep-day
      for (const day of sleepDays) {
        const daySegments = allSegments.filter(s => s.sleep_day_id === day.id);

        // Nap stats (day sleep)
        const naps = daySegments.filter(s => s.kind === "sleep" && s.type === "day sleep");
        const napCount = naps.length;
        const totalNapSeconds = naps.reduce((sum, s) => sum + s.duration_seconds, 0);
        const avgNapSeconds = napCount > 0 ? totalNapSeconds / napCount : 0;

        // Night sleep stats
        const nightSleeps = daySegments.filter(s => s.kind === "sleep" && s.type === "night sleep");
        const nightSleepCount = nightSleeps.length;
        const totalNightSeconds = nightSleeps.reduce((sum, s) => sum + s.duration_seconds, 0);
        const avgNightBlockSeconds = nightSleepCount > 0 ? totalNightSeconds / nightSleepCount : 0;

        // Night awakenings: wake segments that occur between night sleep blocks
        // (not at the edges of the night period)
        const sortedNightSleeps = [...nightSleeps].sort((a, b) => a.start.toMillis() - b.start.toMillis());
        let nightAwakenings = 0;
        if (sortedNightSleeps.length > 1) {
          for (let i = 0; i < sortedNightSleeps.length - 1; i++) {
            // Check if there's a gap between consecutive night sleeps
            if (sortedNightSleeps[i + 1].start > sortedNightSleeps[i].end) {
              nightAwakenings++;
            }
          }
        }

        // Store summary on day object
        day.summary = {
          nap_count: napCount,
          nap_total_seconds: totalNapSeconds,
          nap_total_pretty: formatDurationPretty(totalNapSeconds),
          nap_avg_seconds: avgNapSeconds,
          nap_avg_pretty: formatDurationPretty(avgNapSeconds),
          night_awakenings: nightAwakenings,
          night_sleep_count: nightSleepCount,
          night_total_seconds: totalNightSeconds,
          night_total_pretty: formatDurationPretty(totalNightSeconds),
          night_avg_seconds: avgNightBlockSeconds,
          night_avg_pretty: formatDurationPretty(avgNightBlockSeconds),
        };
      }

      // 6) Build render-friendly fields: offset seconds and tooltip strings
      const sleepDayById = new Map(sleepDays.map(d => [d.id, d]));

      const segments = allSegments.map(seg => {
        const day = sleepDayById.get(seg.sleep_day_id);
        const offsetStart = (seg.start.toMillis() - day.window_start.toMillis()) / 1000;
        const offsetEnd = (seg.end.toMillis() - day.window_start.toMillis()) / 1000;

        // Check if segment has any metadata
        const hasMetadata = !!(seg.start_condition || seg.end_condition || seg.start_location || seg.notes);

        // Build metadata lines with labels, handling newlines in values
        const metaLines = [];
        if (seg.start_condition) metaLines.push(`Start: ${seg.start_condition.replace(/\\n/g, '\n')}`);
        if (seg.end_condition) metaLines.push(`End: ${seg.end_condition.replace(/\\n/g, '\n')}`);
        if (seg.start_location) metaLines.push(`Location: ${seg.start_location.replace(/\\n/g, '\n')}`);
        if (seg.notes) metaLines.push(`Notes: ${seg.notes.replace(/\\n/g, '\n')}`);

        // Build tooltip: time range + duration + metadata with spacing
        const details =
          `${seg.start.toFormat("HH:mm")} → ${seg.end.toFormat("HH:mm")}  (${seg.duration_pretty})` +
          (metaLines.length ? `\n\n${metaLines.join("\n")}` : "");

        return {
          ...seg,
          offset_start_s: offsetStart,
          offset_end_s: offsetEnd,
          has_metadata: hasMetadata,
          label: seg.duration_pretty,
          details
        };
      });

      return {
        timezone,
        sleep_day_start_hour,
        sleep_days: sleepDays.map(d => ({
          id: d.id,
          window_start: d.window_start.toISO(),
          window_end: d.window_end.toISO(),
          summary: d.summary
        })),
        // Keep Luxon versions internally for render convenience
        _sleep_days_luxon: sleepDays,
        segments
      };
    }

    /**
     * =========================
     * Visualization Layer (D3) - Vertical Orientation
     * =========================
     */

    function renderSleepChart(model, opts = {}) {
      const {
        container = "#chart",
        tooltipEl = "#tooltip",
        columnWidth = 140,      // width per day column (generous)
        columnGap = 10,
        timeAxisWidth = 50,     // left margin for time labels
        chartHeight = 920,      // height for the 24h window (generous)
        summaryHeight = 130     // space for summary stats below chart
      } = opts;

      const sleepDays = model._sleep_days_luxon;
      const segments = model.segments;

      const totalSeconds = 24 * 60 * 60; // 18:00 → next 18:00

      // Dimensions
      const width = timeAxisWidth + sleepDays.length * (columnWidth + columnGap) + 20;
      const innerHeight = chartHeight - 60; // leave room for column labels at top

      // Clear
      d3.select(container).selectAll("*").remove();

      const svg = d3.select(container)
        .append("svg")
        .attr("width", width)
        .attr("height", chartHeight + summaryHeight);

      const g = svg.append("g").attr("transform", `translate(${timeAxisWidth}, 40)`);

      // Scales
      // Y-axis: time (18:00 at top → next 18:00 at bottom)
      const y = d3.scaleLinear()
        .domain([0, totalSeconds])
        .range([0, innerHeight]);

      // X-axis: sleep-days (columns)
      const x = d3.scaleBand()
        .domain(sleepDays.map(d => d.id))
        .range([0, sleepDays.length * (columnWidth + columnGap)])
        .paddingInner(columnGap / (columnWidth + columnGap));

      // Axis ticks every 2 hours
      const tickEveryHours = 2;
      const ticks = d3.range(0, 24 + 0.0001, tickEveryHours).map(h => h * 3600);

      const tickFormat = (secFromWindowStart) => {
        const base = sleepDays[0]?.window_start ?? DateTime.local();
        const t = base.plus({ seconds: secFromWindowStart });
        return t.toFormat("HH:mm");
      };

      // Horizontal grid lines
      g.append("g")
        .attr("class", "grid")
        .call(d3.axisLeft(y)
          .tickValues(ticks)
          .tickSize(-x.range()[1])
          .tickFormat("")
        );

      // Y axis (left) - time labels
      g.append("g")
        .attr("class", "axis")
        .call(d3.axisLeft(y).tickValues(ticks).tickFormat(tickFormat));

      // Column labels (date at top)
      g.selectAll(".column-label")
        .data(sleepDays)
        .enter()
        .append("text")
        .attr("class", "column-label")
        .attr("x", d => (x(d.id) ?? 0) + columnWidth / 2)
        .attr("y", -12)
        .attr("text-anchor", "middle")
        .text(d => {
          // Format as "Mon 12/08"
          const dt = DateTime.fromISO(d.id);
          return dt.toFormat("ccc MM/dd");
        });

      // Color mapping for sleep types - improved contrast
      const sleepTypeColors = new Map([
        ["night sleep", "#1e40af"], // dark blue (blue-800)
        ["day sleep", "#60a5fa"],   // lighter blue (blue-400)
      ]);
      const wakeColor = "#d1d5db"; // light gray

      const tooltip = document.querySelector(tooltipEl);

      const bars = g.append("g")
        .selectAll("g.segment")
        .data(segments)
        .enter()
        .append("g")
        .attr("class", "segment");

      // Bar rects (vertical bars)
      bars.append("rect")
        .attr("class", d => `bar ${d.kind}`)
        .attr("x", d => x(d.sleep_day_id) ?? 0)
        .attr("y", d => y(d.offset_start_s))
        .attr("width", columnWidth)
        .attr("height", d => Math.max(0, y(d.offset_end_s) - y(d.offset_start_s)))
        .attr("fill", d => {
          if (d.kind === "wake") return wakeColor;
          return sleepTypeColors.get(d.type) ?? "#6ee7b7";
        })
        .on("mousemove", (event, d) => {
          tooltip.style.display = "block";
          tooltip.textContent = d.details;
          const pad = 12;
          tooltip.style.left = `${Math.min(window.innerWidth - 400, event.clientX + pad)}px`;
          tooltip.style.top = `${Math.min(window.innerHeight - 150, event.clientY + pad)}px`;
        })
        .on("mouseleave", () => {
          tooltip.style.display = "none";
        });

      // Duration labels only (metadata in tooltip)
      // If bar is too short, skip label entirely (tooltip has all info)
      const minHeightForDuration = 24;

      // Helper: check if bar needs light (white) text
      const needsLightText = d => d.type === "night sleep";

      bars.filter(d => {
        const barHeight = y(d.offset_end_s) - y(d.offset_start_s);
        return barHeight >= minHeightForDuration;
      })
        .append("text")
        .attr("class", d => needsLightText(d) ? "bar-label light" : "bar-label")
        .attr("x", d => (x(d.sleep_day_id) ?? 0) + columnWidth / 2)
        .attr("y", d => {
          const y0 = y(d.offset_start_s);
          const y1 = y(d.offset_end_s);
          return y0 + (y1 - y0) / 2;
        })
        .attr("text-anchor", "middle")
        .attr("dominant-baseline", "middle")
        .attr("font-weight", "600")
        .text(d => d.label);

      // Metadata indicator: dot in top-right corner for bars with metadata
      bars.filter(d => d.has_metadata && d.kind === "sleep")
        .append("circle")
        .attr("cx", d => (x(d.sleep_day_id) ?? 0) + columnWidth - 10)
        .attr("cy", d => y(d.offset_start_s) + 10)
        .attr("r", 5)
        .attr("fill", d => needsLightText(d) ? "#ffffff" : "#1e3a5f")
        .attr("stroke", d => needsLightText(d) ? "rgba(0,0,0,0.3)" : "rgba(255,255,255,0.5)")
        .attr("stroke-width", 1.5)
        .attr("class", "metadata-indicator");

      // Divider line between chart and summary
      g.append("line")
        .attr("x1", 0)
        .attr("y1", innerHeight + 6)
        .attr("x2", x.range()[1])
        .attr("y2", innerHeight + 6)
        .attr("stroke", "#e5e7eb")
        .attr("stroke-width", 1);

      // Summary stats below each column
      const summaryGroup = g.append("g")
        .attr("class", "summary")
        .attr("transform", `translate(0, ${innerHeight + 20})`);

      const summaryData = model.sleep_days;

      summaryData.forEach(day => {
        const colX = x(day.id) ?? 0;
        const s = day.summary;
        const lineHeight = 16;

        const lines = [
          { label: "Naps", value: `${s.nap_count} (${s.nap_total_pretty})` },
          { label: "Avg nap", value: s.nap_avg_pretty },
          { label: "Night", value: `${s.night_total_pretty}` },
          { label: "Avg block", value: s.night_avg_pretty },
          { label: "Awakenings", value: `${s.night_awakenings}` },
        ];

        lines.forEach((line, i) => {
          // Label
          summaryGroup.append("text")
            .attr("x", colX + 4)
            .attr("y", i * lineHeight)
            .attr("font-size", "10px")
            .attr("fill", "#6b7280")
            .text(line.label);

          // Value
          summaryGroup.append("text")
            .attr("x", colX + columnWidth - 4)
            .attr("y", i * lineHeight)
            .attr("font-size", "10px")
            .attr("fill", "#111827")
            .attr("text-anchor", "end")
            .attr("font-weight", "500")
            .text(line.value);
        });
      });
    }

    /**
     * =========================
     * Load data and render
     * =========================
     */

    const TIMEZONE = "America/Sao_Paulo";
    const SLEEP_DAY_START_HOUR = 6; // Start at 6am (morning)

    let allEvents = [];

    /**
     * Filter events to only include the last N days (based on sleep-day windows)
     */
    function filterEventsByDays(events, numDays) {
      if (numDays === "all" || !numDays) return events;

      // Find the latest sleep-day in the data
      let latestSleepDay = null;
      for (const e of events) {
        const dt = dtFromISO(e.start, TIMEZONE);
        const sleepDayId = sleepDayIdFromDt(dt, SLEEP_DAY_START_HOUR);
        if (!latestSleepDay || sleepDayId > latestSleepDay) {
          latestSleepDay = sleepDayId;
        }
      }

      if (!latestSleepDay) return events;

      // Calculate cutoff date (numDays before the latest)
      const latestDt = DateTime.fromISO(latestSleepDay, { zone: TIMEZONE });
      const cutoffDt = latestDt.minus({ days: numDays - 1 });
      const cutoffId = cutoffDt.toISODate();

      // Filter events where the sleep-day is >= cutoff
      return events.filter(e => {
        const dt = dtFromISO(e.start, TIMEZONE);
        const sleepDayId = sleepDayIdFromDt(dt, SLEEP_DAY_START_HOUR);
        return sleepDayId >= cutoffId;
      });
    }

    function render(numDays) {
      const filteredEvents = filterEventsByDays(allEvents, numDays);

      if (filteredEvents.length === 0) {
        document.querySelector("#errors").innerHTML =
          `<div class="error">No sleep data found. Run <code>make build</code> to generate data/sleep.json</div>`;
        return;
      }

      const input = {
        timezone: TIMEZONE,
        sleep_day_start_hour: SLEEP_DAY_START_HOUR,
        events: filteredEvents
      };

      try {
        document.querySelector("#errors").innerHTML = "";
        const model = buildSleepChartModel(input);
        renderSleepChart(model);
      } catch (err) {
        document.querySelector("#errors").innerHTML =
          `<div class="error"><strong>Validation error</strong><pre style="margin:8px 0 0; white-space:pre-wrap;">${String(err.message)}</pre></div>`;
      }
    }

    // Wire up days selector
    const daysSelect = document.querySelector("#days-select");
    daysSelect.addEventListener("change", () => {
      const val = daysSelect.value;
      render(val === "all" ? "all" : parseInt(val, 10));
    });

    // Load data and render
    fetch("data/sleep.json")
      .then(res => {
        if (!res.ok) throw new Error(`Failed to load data/sleep.json (${res.status})`);
        return res.json();
      })
      .then(data => {
        allEvents = data;
        render(7);
      })
      .catch(err => {
        document.querySelector("#errors").innerHTML =
          `<div class="error"><strong>Failed to load data</strong><br>${err.message}<br><br>Run <code>make build</code> to generate the data file.</div>`;
      });
  </script>
</body>
</html>
